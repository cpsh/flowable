<?xml version="1.0" encoding="UTF-8"?>
<!-- Maven Pom文件标签详解 -->
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么副项目中的对应值即为项目的默认值。坐标包括groupId,artifactId,version -->
    <parent>
        <!-- 被继承的父项目的唯一标识符 -->
        <groupId></groupId>
        <!-- 被继承的父项目的构建标识符 -->
        <artifactId></artifactId>
        <!-- 被继承的父项目的版本 -->
        <version></version>
        <!-- 父项目的pom.xml文件的相对路径。相对路径允许选择一个不同的路径，默认是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom -->
        <relativePath></relativePath>
    </parent>
    <!--声明项目描述符遵循哪一个POM模型版本，模型本身版本很少改变，但仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性-->
    <modelVersion></modelVersion>
    <!--项目的唯一标识符，通常使用权限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成，如com.mycompany.app生成的相对路径为com/mycompany/app-->
    <groupId></groupId>
    <!--构件的标识符，和groupId一起唯一标识一个构件，两个不同项目不能拥有相同的groupId和artifactId。构件是项目产生或者使用的东西，Maven为项目生成的构件包括：jar、源码、二进制发布和war等-->
    <artifactId></artifactId>
    <!--项目当前版本 格式为：主版本.次版本.增量版本-限定版本号-->
    <version></version>
    <!--项目产生的构件类型 例如 jar、war、pom、ear。插件可以创建自己的构件类型-->
    <packaging></packaging>
    <!--项目的名称，Maven产生的文档中使用-->
    <name></name>
    <!--项目主页的URL，Maven产生的文档中使用-->
    <url></url>
    <!--项目的详细描述，Maven产生的文档使用，当这个元素能够用HTML格式描述（CDATA），不推荐使用纯文本描述。-->
    <description></description>
    <!--描述了这个项目构建环境中的前提条件-->
    <prerequisites>
        <!--构建这个项目或者使用该插件所需要的Maven最低版本-->
        <maven></maven>
    </prerequisites>
    <!--项目的问题管理系统（Bugzilla，jiar，Scarab，或任何问题管理系统）的名称和URL-->
    <issueManagement>
        <!--问题管理系统（例如jira）的名字-->
        <system></system>
        <!--该项目使用的问题管理的URL-->
        <url></url>
    </issueManagement>
    <!--项目持续集成信息-->
    <ciManagement>
        <!--持续集成系统的名字-->
        <system></system>
        <!--该项目使用的持续集成系统的URL（如果持续集成系统中有web接口的话）-->
        <url></url>
        <!--构建完成时，需要通知的开发者/用户的配置项。包括被统治者信息和通知条件-->
        <notifiers>
            <!--配置一种方式，当构建中断时，以改方式通知用户/开发者-->
            <notifier>
                <!--传送通知的途径-->
                <type></type>
                <!--发生错误时是否通知-->
                <sendOnError></sendOnError>
                <!--构建成功时是否通知-->
                <sendOnSuccess></sendOnSuccess>
                <!--发生警告时是否通知-->
                <sendOnWarning></sendOnWarning>
                <!--构建失败时是否通知-->
                <sendOnFailure></sendOnFailure>
                <!--不推荐使用-->
                <address></address>
                <!--扩展配置项-->
                <configuration/>
            </notifier>
        </notifiers>
    </ciManagement>
    <!--项目创建年份，4位数字，版权信息需要使用-->
    <inceptionYear></inceptionYear>
    <!--项目相关邮件列表信息-->
    <mailingLists>
        <!--描述了项目相关的所有邮件列表，自动产生的网站引用这些信息-->
        <mailingList>
            <!--邮件名称-->
            <name></name>
            <!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto:链接会被自动创建-->
            <post></post>
            <!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto:链接自动创建-->
            <subscribe></subscribe>
            <!--取消订阅邮件的地址或链接-->
            <unsubscribe></unsubscribe>
            <!--可以浏览邮件信息的URL-->
            <archive></archive>
        </mailingList>
    </mailingLists>
    <!--项目开发者列表-->
    <developers>
        <!--某个开发者的信息-->
        <developer>
            <!--SCM里项目开发者的唯一标识福-->
            <id></id>
            <!--全名-->
            <name></name>
            <!--邮箱地址-->
            <email></email>
            <!--个人主页地址-->
            <url></url>
            <!--项目开发者在项目中扮演的角色,描述了各种角色-->
            <roles>
                <role></role>
            </roles>
            <!--所属组织-->
            <organization></organization>
            <!--所属组织URL-->
            <organizationUrl></organizationUrl>
            <!--开发者属性，如即使消息如果处理等-->
            <properties>
                <dept></dept>
            </properties>
            <!--所属时区-->
            <timezone></timezone>
        </developer>
    </developers>
    <!--项目其他贡献者参见developers/developer元素-->
    <contributors>
        <contributor></contributor>
    </contributors>
    <!--项目所有License列表。应该只列出该项目的license列表，不要列出依赖项目的。如果列出多个，用户可以选择-->
    <licenses>
        <!--描述项目的license证件、执照,用于生成项目的web站点的license页面-->
        <license>
            <!--法律上的名称-->
            <name></name>
            <!--正文页面的URL-->
            <url></url>
            <!--项目分发的主要方式：repo可以从Maven库下载，manual，用户必须手动下载和安装依赖-->
            <distribution></distribution>
            <!--补充信息-->
            <comments></comments>
        </license>
    </licenses>
    <!--SCM（source control management）允许配置代码库-->
    <scm>
        <!--SCM的URL，描述版本库和如何连接到版本库-->
        <connection></connection>
        <!--给开发者使用，类似connection，不仅仅是只读-->
        <developerConnection></developerConnection>
        <!--单钱代码的标签，在开发阶段默认是HEAD-->
        <tag></tag>
        <!--指向项目可浏览的SCM库的URL-->
        <url></url>
    </scm>
    <!--项目所属组织的各种属性,文档时使用-->
    <organization>
        <name></name>
        <url></url>
    </organization>
    <!--构建项目需要的信息-->
    <build>
        <!--设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的编码。改路径时相对于pom.xml的相对路径-->
        <sourceDirectory></sourceDirectory>
        <!--设置了项目脚本源码目录，该目录和源码目录不同，绝大多数情况下，该目录下的内容会被拷贝到输出目录（脚本是被解释的，无需编译）-->
        <scriptSourceDirectory></scriptSourceDirectory>
        <!--设置了单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码，相对pom.xml的相对路径-->
        <testSourceDirectory></testSourceDirectory>
        <!--被编译过的应用程序class文件存放的目录-->
        <outputDirectory></outputDirectory>
        <!--被编译过的测试class文件存放的目录-->
        <testOutputDirectory></testOutputDirectory>
        <!--使用来自该项目的一系统构建扩展-->
        <extensions>
            <!--构建扩展-->
            <extension>
                <groupId></groupId>
                <artifactId></artifactId>
                <version></version>
            </extension>
        </extensions>
        <!--当项目没有规定目标时的默认值-->
        <defaultGoal></defaultGoal>
        <!--相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里-->
        <resources>
            <!--项目相关或测试相关的所有资源路径-->
            <resource>
                <!--描述了资源的目标路径。该路径相对target/classes目录(${project.build.outputDirectory}),指定放在包中则需要配置-->
                <targetPath></targetPath>
                <!--是否使用参数值代替参数名。参数值取自properties元素或者文件里的配置的属性，文件在filters元素中列出-->
                <filtering></filtering>
                <!--存放资源的路径，盖伦相对POM路径-->
                <directory></directory>
                <!--包含的模式列表 如**/*.xml-->
                <includes></includes>
                <!--排除的模式列表-->
                <excludes></excludes>
            </resource>
        </resources>
        <!--测试相关资源路径-->
        <testResources>
            <testResource></testResource>
        </testResources>
        <!--构建产生的所有文件存放的目录-->
        <directory></directory>
        <!--生成的构建的文件名 默认值时${artifactId}-${version}-->
        <finalName></finalName>
        <!--当filtering开关打开时，使用的过滤器属性文件列表-->
        <filters></filters>
        <!--子项目可以引用的默认插件信息，该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置-->
        <pluginManagement>
            <!--使用的插件列表-->
            <plugins>
                <!--包含描述插件所需的信息-->
                <plugin>
                    <groupId></groupId>
                    <artifactId></artifactId>
                    <version></version>
                    <!--作为DOM对象的配置-->
                    <configuration></configuration>
                    <!--在构建生命周期中执行一组目标的配置，每个目标可能有不同配置-->
                    <executions>
                        <!--包含了插件执行需要的信息-->
                        <execution>
                            <!--执行目标的标识符，用于标识构建过程中的目标-->
                            <id></id>
                            <!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到元数据里配置的默认阶段-->
                            <phase></phase>
                            <!--执行目标-->
                            <goals>
                                <goal></goal>
                            </goals>
                            <!--是否传播到子POM-->
                            <inherited></inherited>
                            <!--作为DOM对象的配置-->
                            <configuration></configuration>
                        </execution>
                    </executions>
                    <!--项目映入插件所需要的额外依赖-->
                    <dependencies></dependencies>
                    <!--是否可以传播到子POM-->
                    <inherited></inherited>
                    <!--是否从该插件下载Maven扩展，由于性能原因，只有在真正下载的时候，才被设置为enabled-->
                    <extensions></extensions>
                </plugin>
            </plugins>
        </pluginManagement>
        <!--使用的插件列表-->
        <plugins></plugins>
    </build>
    <!--在列的项目构建profile，如果被集火，会修改构建处理-->
    <profiles>
        <!--根据环境参数或者命令行参数激活某个构建处理-->
        <profile>
            <!--构建配置的唯一标识符，及用于命令行激活，也用于在继承时合并具有相同标识符的profile-->
            <id></id>
            <!--自动触发profile的条件逻辑。Activation是profile开启钥匙。profile的力量在于能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式-->
            <activation>
                <!--profile默认是否激活的标识-->
                <activeByDefault></activeByDefault>
                <!--当匹配的jdk被检测到时激活 !1.4激活所有不以1.4开头的jdk-->
                <jdk></jdk>
                <!--当匹配的操作系统属性被检测到，profile被激活-->
                <os>
                    <!--激活profile的操作系统名字-->
                    <name></name>
                    <!--激活profile的操作系统所属系统-->
                    <family></family>
                    <!--激活profile的操作系统体系结构-->
                    <arch></arch>
                    <!--激活profile的操作系统体系结构-->
                    <version></version>
                </os>
                <!--Maven检测到某个属性（${}引用），其拥有对应的名称和值，profile就会被激活。大小写匹配，没有值则有key就激活-->
                <property>
                    <!--激活的属性名称-->
                    <name></name>
                    <!--激活的值-->
                    <value></value>
                </property>
                <!--提供文件名，通过检测文件是否存在来激活profile-->
                <file>
                    <!--指定文件存在则激活-->
                    <exists></exists>
                    <!--指定文件不存在则激活-->
                    <missing></missing>
                </file>
            </activation>
            <!--profile使用的构建信息-->
            <build>
                <!--详见以上build-->
            </build>
            <!--模块（也被称为子项目）被构建成项目的一部分，列出每个模块元素是指向该模块的目录的相对路径-->
            <modules></modules>
            <!--远程仓库列表-->
            <repositories>

            </repositories>
            <!--插件的远程仓库-->
            <pluginRepositories>

            </pluginRepositories>
            <!--描述了项目相关的所有依赖-->
            <dependencies>

            </dependencies>
            <!--钙元素包括使用报表插件产生报表的规范，执行mvn site，运行-->
            <reporting>

            </reporting>
            <!---->
            <dependencyManagement>
                <dependencies>

                </dependencies>
            </dependencyManagement>
            <distributionManagement>

            </distributionManagement>
            <properties/>
        </profile>
    </profiles>
    <!--模块（也称为子项目）被构建成项目的一部分。列出每个模块元素是指向该模块的目录的相对路径-->
    <modules></modules>
    <!--远程仓库列表-->
    <repositories>
        <!--远程仓库信息-->
        <repository>
            <!--如果处理远程仓库发布版本的下载-->
            <releases>
                <!--true或false表示该仓库是否为下载某种类型构件（发布版、快照）开启-->
                <enabled></enabled>
                <!--指定更新发生的频率。会比较本地和远程POM的时间戳，选项为：always(一直)、daily（每日）、interval：X（间隔以单位分钟），never（从不）-->
                <updatePolicy></updatePolicy>
                <!--验证构件文件失败：ignore忽略，fail失败，或者warn（警告）-->
                <checksumPolicy></checksumPolicy>
            </releases>
            <!--如何处理远程仓库快照版本的下载-->
            <snapshots>
                <enabled></enabled>
                <updatePolicy></updatePolicy>
                <checksumPolicy></checksumPolicy>
            </snapshots>
            <!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库-->
            <id></id>
            <!--名称-->
            <name></name>
            <!--远程仓库URL-->
            <url></url>
            <!--用于定位和排序构件的仓库布局类型可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。-->
            <layout></layout>
        </repository>
    </repositories>
    <!--插件的远程仓库列表-->
    <pluginRepositories>

    </pluginRepositories>
    <!--项目相关的所有依赖-->
    <dependencies>
        <dependency>
            <groupId></groupId>
            <artifactId></artifactId>
            <version></version>
            <!--依赖类型，默认类型是jar，通常表示依赖文件的扩展名-->
            <type></type>
            <!--依赖的分类器-->
            <classifier></classifier>
            <!--一依赖范围
                compiler:默认范围 用于编译
                test:用于test任务时
                provided:类似于编译，但支持期待jdk或容器提供，类似于classpath
                runtime:在执行时需要使用
                system:需要提供外在相应的元素，通过systemPath取得
                systemPath:仅用于范围system，提供相应的路径
                optional:项目自身被依赖时，标注依赖是否传递，用于连续时使用-->
            <scope></scope>
            <!--仅用于system范围时，不推荐使用-->
            <systemPath></systemPath>
            <!--当计算传递依赖时，从依赖构件列表中，列出被排除的依赖构建集。主要用于解决版本冲突问题-->
            <exclusions>
                <exclusion>
                    <groupId></groupId>
                    <artifactId></artifactId>
                </exclusion>
            </exclusions>
            <!--可选依赖，阻断依赖的传递性-->
            <optional></optional>
        </dependency>
    </dependencies>
    <!--使用报表插件产生报表的规范-->
    <reporting>
        <!--true，则网站不包括默认的报表。-->
        <excludeDefaults></excludeDefaults>
        <!--产生报表存放位置，默认为${project.build.outputDirectory}/site-->
        <outputDirectory></outputDirectory>
        <!--使用的报表插件和配置-->
        <plugins>
            <plugin>
                <groupId></groupId>
                <artifactId></artifactId>
                <version></version>
                <inherited></inherited>
                <configuration></configuration>
                <!--一组报表的多重规范，每个规范可能有不同的配置。一个规范对应一个执行目标。例如，有个1-9个报表，1,2,4构成A报表集，对应一个执行目标，2,5,8构成B报表集，对应另一个执行目标-->
                <reportSets>
                    <reportSet>
                        <!--报表集唯一标识符，POM继承时使用-->
                        <id></id>
                        <!--产生报表集合时，被使用的报表的配置-->
                        <configuration/>
                        <!--是否被继承到子POM中-->
                        <inherited></inherited>
                        <!--这个集合中使用哪些报表-->
                        <reports></reports>
                    </reportSet>
                </reportSets>
            </plugin>
        </plugins>
    </reporting>
    <!--继承自该项目的所有子项目的默认依赖信息，这部分的以来信息不会被立即解析，而是当子项目中声明一个依赖，但是除了groupId和artifactId之外的信息没有描述时，则使用这里的依赖信息-->
    <dependencyManagement>
        <dependencies>

        </dependencies>
    </dependencyManagement>
    <!--项目分发信息，在执行mvn deploy后表示要发布的位置,有了这些信息就可以把网站部署到远程服务器或者把构建部署到远程仓库-->
    <distributionManagement>
        <!--部署项目产生的构件到远程仓库需要的信息-->
        <repository>
            <!--唯一的版本号-->
            <uniqueVersion></uniqueVersion>
            <!---->
            <id></id>
            <name></name>
            <url></url>
            <layout></layout>
        </repository>
        <!--快照版本部署位置，没有配置则默认配置到repository的位置-->
        <snapshotRepository>

        </snapshotRepository>
        <!--部署项目网站需要的信息-->
        <site>

        </site>
        <downloadUrl></downloadUrl>
        <!--如果构件有了新的groupId和artifactId（构建移动到了新的位置），这里列出构建的重定位信息-->
        <relocation>
            <!--构建新的groupId-->
            <groupId></groupId>
            <!--新artifactId-->
            <artifactId></artifactId>
            <!--新版本号-->
            <version></version>
            <!--显示给用户的，关于移动的额外信息，例如原因-->
            <message></message>
        </relocation>
        <!--给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。-->
        <status></status>
    </distributionManagement>
    <!--以值替代名称。Properties可以在整个POM中使用，也可以作为触发条件。格式<name>value</name>-->
    <properties/>
</project>